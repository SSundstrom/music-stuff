enum SessionStatus {
  active
  archived
}

// Container for multiple tournaments
model GameSession {
  id        String        @id
  ownerId   String
  status    SessionStatus @default(active)
  createdAt DateTime

  tournaments Tournament[]
  players     Player[]

  @@index([ownerId], map: "idx_sessions_owner")
}

enum TournamentStatus {
  waiting
  category_selection
  song_submission
  tournament
  finished
}

// Individual category tournaments within a session
model Tournament {
  id                 String           @id
  sessionId          String
  category           String
  status             TournamentStatus @default(waiting)
  currentPickerIndex Int              @default(0)
  winningSongId      String?
  createdAt          DateTime

  session GameSession       @relation(fields: [sessionId], references: [id])
  songs   Song[]
  matches TournamentMatch[]

  @@index([sessionId], map: "idx_tournaments_session")
}

// Players join a session, participate in all tournaments
model Player {
  id              String   @id
  sessionId       String
  name            String
  spotifyDeviceId String?
  isOwner         Boolean  @default(false)
  joinOrder       Int
  createdAt       DateTime

  session GameSession @relation(fields: [sessionId], references: [id])
  songs   Song[]
  votes   Vote[]

  @@index([sessionId], map: "idx_players_session")
}

// Songs are submitted per tournament
model Song {
  id           String   @id
  tournamentId String
  spotifyId    String
  playerId     String
  startTime    Int
  songName     String
  artistName   String
  imageUrl     String?
  createdAt    DateTime

  tournament     Tournament        @relation(fields: [tournamentId], references: [id])
  player         Player            @relation(fields: [playerId], references: [id])
  matchesAsA     TournamentMatch[] @relation("songA")
  matchesAsB     TournamentMatch[] @relation("songB")
  votes          Vote[]
  matchesPlaying TournamentMatch[] @relation("currentlyPlaying")

  @@unique([playerId, tournamentId])
  @@index([tournamentId], map: "idx_songs_tournament")
}

enum MatchStatus {
  pending
  playing
  voting
  completed
}

// Matches are per tournament
model TournamentMatch {
  id                     String      @id
  tournamentId           String
  roundNumber            Int
  songAId                String?
  songBId                String?
  winnerId               String?
  status                 MatchStatus @default(pending)
  votesA                 Int         @default(0)
  votesB                 Int         @default(0)
  currentlyPlayingSongId String?
  createdAt              DateTime

  tournament       Tournament @relation(fields: [tournamentId], references: [id])
  songA            Song?      @relation("songA", fields: [songAId], references: [id])
  songB            Song?      @relation("songB", fields: [songBId], references: [id])
  currentlyPlaying Song?      @relation("currentlyPlaying", fields: [currentlyPlayingSongId], references: [id])
  votes            Vote[]

  @@index([tournamentId], map: "idx_matches_tournament")
  @@index([tournamentId, roundNumber], map: "idx_matches_round")
}

// Votes table
model Vote {
  id        String   @id
  matchId   String
  playerId  String
  songId    String
  createdAt DateTime

  match  TournamentMatch @relation(fields: [matchId], references: [id])
  player Player          @relation(fields: [playerId], references: [id])
  song   Song            @relation(fields: [songId], references: [id])

  @@unique([matchId, playerId], map: "votes_match_id_player_id_key")
  @@index([matchId], map: "idx_votes_match")
}
